<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Kevin Henriques - BCC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="bootstrap-reboot.min.css">
  <link rel="stylesheet" type="text/css" href="style.css"> <!--  link para o arquivo CSS -->

  <link rel="stylesheet" type="text/css" href="style.css"> <!--  link para o arquivo CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-tomorrow.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Lato:wght@100;400;900&family=Roboto:wght@100;300;400;700&family=Roboto+Condensed:wght@300;400;500;700&display=swap"
    rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js" crossorigin="anonymous"
    referrerpolicy="no-referrer"></script> <!-- Arquivo JavaScript para o efeito parallax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-java.min.js"
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-python.min.js"
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript" src="processing.js"></script>
  <script src="script.js" defer></script>
</head>

<body>

  <main>

    <section id="phome" style="max-width: 100%; margin: 0px auto; padding: 0;">
      <header>
        <div>
          <h1>Kevin Henriques</h1>
          <h4 style="font-size: 24pt;">TDE - Experiência Criativa</h4>
        </div>
      </header>
    </section>

    <section id="expcrt">
      <h3>Experiência Criativa</h3>
      <div>
        <p>
          &emsp;Na matéria temos trabalho que usamos o conhecimento que adquirimos nas outras matérias e também o
          conhecimento
          prático, muito útil na "simulação" da vida real, em que, muitas vezes, temos que resolver os problemas por nós
          mesmos. Teve um projeto individual para programar um personagem e até agora fiz par
          te do grupo 5G, em que
          fizemos o primeiro projeto TYP, como um jogo de plataforma, e outro jogo que é uma réplica de um clássico
          chamado Arkanoid, que foi nosso segundo trabalho como Aplicativo Multimedia.
        </p>
      </div>

      <h4>Processing</h4>
      <div class="flex-column">

        <p style="display: block;"> &emsp;Processing é uma linguagem de programação e um ambiente de desenvolvimento
          integrado
          (IDE) criado para
          artistas e designers que desejam explorar a programação e a computação visual. Ele foi desenvolvido por Casey
          Reas e Ben Fry no MIT Media Lab em 2001 e é amplamente utilizado para criar projetos interativos, gráficos e
          animações. <br><br>
          &emsp;Ele é baseado na linguagem de programação Java, mas oferece uma sintaxe simplificada e uma série de
          funções e bibliotecas específicas para o trabalho com gráficos, áudio, vídeo e interação com o usuário. Ele
          fornece uma abordagem amigável para a programação.<br><br>
          &emsp;Também é uma ferramenta de código aberto e possui uma comunidade ativa de usuários que compartilham
          projetos, tutoriais e bibliotecas, o que facilita a aprendizagem e o desenvolvimento de novas aplicações.
        </p>
        <div class="flex-row">
          <p>
            &emsp;O primeiro projeto que fiz foi usando a IDE Processing para programar um personagem. Não tinha
            experiência
            nenhuma com Java, e mal tinha começado a aprender Python. <br> &emsp;Porém, esse projeto me fez aprender
            muito!
            Mesmo quebrando muito a cabeça para tentar usar funções e organizar o código da forma que eu queria
            , tive muita dificuldade para entender o pushMatrix() e popMatrix() à principio, com o tempo fui me
            acostumando com a forma de usar e conseguindo fazer cada vez mais rápido, com menos erros e menos testes.
            <br><br>
            &emsp;Fiquei muito orgulhoso do resultado, que, mesmo não tendo experiência consegui realizar algo, algo
            meu, e
            que fiquei muito feliz com o resultado. <br><br>
            Vou disponibilizar os códigos dos meus projetos individuais aqui também.

          </p>
          <img src="/assets/Panda.png" alt="Teste Descrição" height="400px">
        </div>
        <pre><code class="language-java" style="display:block;height: 500px;width:1000px;font-size:medium;" >
void setup(){
  size(800,800);
  ellipseMode(CENTER);
}
// função que tem parametros de angulo, espaçamento e o brilho dos olhos separado, assim
// podendo repetir a função alterando apenas alguns paramentros. Usei pra simular um "mirror".
void eye(float x, float y, float angle, float eyeSpacing, float eyeShine){ 
  //MARCA DOS OLHOS
  noStroke();
  // a funçào	pushMatrix e popMatrix faz com o que existe dentro dela não altere o resto do código. 
  // Usei pra conseguir rotacionar uma parte sem rotacionar todo o resto.
  pushMatrix();
  // translate x e y ele usa a posição como parâmetro da função, podendo modificar em outra função.
  // O translate dentro do pushMatrix e popMatrix faz com o que ele usei a posição da função como a dele.
  // Demorei bastante pra resolver essa parte por causa  das rotações.
  translate(x, y);
  fill(40);
  rotate(radians(angle));
  ellipse(0, 0, 100, 80);
  popMatrix();
  //OLHOS
  fill(255);
  circle(x+eyeSpacing, y-10, 50);
  fill(20);
  circle(x+eyeSpacing, y-10, 40);
  //BRILHO DOS OLHOS
  fill(255);
  circle(x+eyeShine, y-20, 20);
}

void head(float x, float y){
  //ORELHAS
  pushMatrix();
  fill(40);
  circle(x-110, y-120, 100);
  circle(x+110, y-120, 100);
  //CABEÇA
  stroke(40);
  // strokeWeight é usado pra alterar a grossura da linha.
  strokeWeight(10);
  fill(255);
  ellipse(x, y, 300, 280);
  popMatrix();
  //BOCA
  // Fiz um arc usando a medida de radianos, pra mim, ficou mais fácil de manipular.
  arc(x, y+10, 60 , 60, radians(30), radians(150));
  //NARIZ
  ellipse(x, y, 20, 8);
  //OLHOS
  // Criei variáveis para ficar mais fácil a leitura do código e poder editar vários valores ao mesmo tempo.
  float eyeSpacing = 14;
  float eyeAngle = 30;
  float eyeShinePos = 20;
  // Juntei a função "eye" com a "head", fazendo os olhos fazerem parte da cabeça.
  eye(x-70, y-30, -eyeAngle, eyeSpacing, eyeShinePos);
  eye(x+70, y-30, eyeAngle, -eyeSpacing, -eyeShinePos);
}

void limb(float x, float y, float angle, boolean cushions, float size){
  noStroke();
  pushMatrix();
  translate(x,y);
  scale(size);
  rotate(radians(angle));
  fill(40);
  //BASE DOS MEMBROS
  ellipse(0, 0, 110, 150);
  //DEDOS
  ellipse(-30, -55, 30, 40);
  ellipse(-11, -70, 30, 40);
  ellipse(30, -55, 30, 40);
  ellipse(11, -70, 30, 40);
  //ALMOFADAS
  if (cushions){ //if que liga/desliga as almofadas pra usar o mesmo formato pra mãos e pés
    fill(#E8ADBD);
    ellipse(0, 10, 60, 80);
    circle(-28, -45, 15);
    circle(-10, -59, 15);
    circle(28, -45, 15);
    circle(10, -59, 15);
  }
  popMatrix();
  
}
//CORPO
void body(float x, float y){
  stroke(40);
  strokeWeight(10);
  fill(40);
  circle(x, y, 350);
  fill(255);
  ellipse(x, y, 330, 250);
  float footSpacing = 120;
  float footHeight = 110;
  float handSpacing = 130;
  float handHeight = -40;
  float handSize = 0.8;
  float handAngle = 120;
  //MÃOS
  limb(x+handSpacing, y+handHeight, -handAngle, false, handSize);
  limb(x-handSpacing, y+handHeight, handAngle, false, handSize);
  //PÉS
  limb(x+footSpacing, y+footHeight, 30, true, 1);
  limb(x-footSpacing, y+footHeight, -30, true, 1);
}
// função que junta todos os membros do panda
void panda(float x, float y){ 
  if (mousePressed == true) { // If que SE o mouse estiver pressionado, muda a posicao do panda para mouseX e mouseY
    translate(mouseX,mouseY);
  } 
  else {
    translate (width/2, height/2);;
  }
  body(x, y+100);
  head(x, y-100);
  }

void draw(){
  background(128);
  // draw do panda inteiro
    panda(0, 0); 
}
        </code></pre>
      </div>

      <h4>TYP</h4>

      <div class="flex-column">
        <div class="flex-row">
          <img src="/assets/typ_1.gif" play loop height="180px">
          <p>
            &emsp;TYP é um jogo em formato plataforma que foi desenvolvido focado na facilidade da jogabilidade, com
            comandos
            simples mas
            uma mecânica mais complexa, em que o personagem principal "TYP" é um robô que foi descartado por estar
            obsoleto, e misturando
            a história com a mecânica, se você usar muito os comandos dele, (andar, pular, atirar) ele superaquece e
            fica
            imóvel durante
            um curto período de tempo.
          </p>
        </div>
        <div class="flex-row">
          <p>
            &emsp;Usamos o Construct 3, que é uma poderosa ferramenta de desenvolvimento de jogos baseada em navegador.
            É
            amplamente utilizado por desenvolvedores indie e entusiastas de jogos. <br>
            &emsp;O Construct 3 tem uma interface intuitiva e amigável, permitindo que os desenvolvedores criem
            jogos sem a necessidade de conhecimento avançado em programação. Ele usa uma abordagem baseada em
            eventos, em que os podemos definir comportamentos e interações dos elementos do jogo através
            de uma interface gráfica.
          </p>
          <img src="/assets/typ_3.gif" play loop height="180px">
        </div>
        <div class="flex-row">
          <div class="flex-column">
            <h2>Programação</h2>
            <p>
              A programação no Processing é totalmente visual, fazendo a gente focar na lógica dos eventos. <br>
              A minha contribuição foi com a logica de eventos das fases do jogo, algumas do personagem e colocando
              muitos elementos de interação nas fases, como sprites animados e objetos se movendo.
            </p>
          </div>
          <div class="flex-column">
            <h2>Design</h2>
            <p>
              Fiz grande parte do design, incluindo montar sprites, animações, hitboxes, e aplicar todos esses elementos
              nos quadros das fases. <br>
              Cada fase tem algo particular, fora a aparencia geral. <br> Fiz elementos de segundo plano animados para mais
              fluidez e até sprites de cor para transição entre telas. Também ajudei um pouco nos menus, mantendo o mesmo estilo de imagens e animação da pagina de créditos.

            </p>
          </div>
          <div class="flex-column">
            <h2>Level Design</h2>
            <p>
              Dividimos em três, os designs. Planejei a segunda fase, na cidade, onde é o caminho de transição para a
              fase final, e o desafio foi exatamente esse. Fazer a fase se encaixar no meio do caminho, sem uma
              transição abrupta entre telas, fazendo o player se sentir mais imerso no universo do jogo.
          </div>
        </div>
      </div>

      <h4>Programa Multimedia</h4>

      <div class="flex-column">
        <div class="flex-row">
          <div class="flex-column">
            <p>
              &emsp;Nosso programa multimedia escolhemos em também fazer um jogo, e nele uma réplica de um clássico
              chamado
              Arkanoid. <br><br>
              &emsp;A mecânica é bem simples. O player controla uma plataforma que se mexe no exo X, e que fica na base
              da
              janela do jogo.
              Uma bola se move pela tela rebatendo nos cantos, na plataforma do player e nos "bricks" que se roganizam
              no topo da janela em diversas cores. <br><br>
              &emsp;Cada vez que a bola rebate no em um brick, o brick "quebra" e some. O objetivo do jogo é fazer com
              que a
              bola destrua todos os bricks,
              e se o player não rebater a bola e ela for pra fora da janela na parte de baixo, o player perde. <br><br>
              &emsp;A dificuldae do jogo está em rebater a bola sem deixar ela "cair", porém, cada vez que a bola
              rebate, ela
              fica mais rápida, assim ficando cada vez mais difícil para o player rebater com a plataforma.

            </p>

          </div>
          <img src="/assets/pm_gp.png" alt="Teste Descrição" height="400px">
        </div>
        <div class="flex-row">
          <img src="/assets/pm_bg.png" alt="Teste Descrição" height="400px">
          <div class="flex-column">
            <p style="display: block;">
              &emsp;No projeto, eu fiquei responsável pela mecanica dos bricks e juntar o código de todos.
              E assim como nos projetos anteriores, ganhei muita experiência no processo de criação do jogo,
              principalmente na parte de programação envolvendo loops com <i>for</i> e uso de arrays e matrizes. A parte
              que considero mais difícil até agora foi fazer a matriz que representa a posição dos bricks, que tive que,
              basicamente, aprender como usava do 0. <br>
              &emsp;A lógica que usei, foi representar os bricks em uma
              matriz com <i>x</i> e <i>y</i>, e cada ponto da matriz adiciona um brick, e consequentemente aplica um
              valor a cada brick. Esse valor faz com que as cores deles sejam diferentes,
              podendo até colocar resistência, podendo fazer a bola rebater mais de uma vez nele antes de quebrar.
            </p>
            <p style="display: block;">
              &emsp;Também fiquei responsável pela parte gráfica, utilizando conhecimentos de design visual, modelagem
              3D e
              <i>renderização</i>, fazendo a imagem do menu, e toda a parte de gerenciamento de cores, para um visual
              mais
              harmônico.
            </p>
          </div>
        </div>
      </div>
      </div>
    </section>

    <section id="cyber">
      <h3>Fundamentos de Sistemas Cyberfísicos</h3>

      <div>
        <p>
          &emsp;Sistema ciberfísico, é uma combinação de sistemas computacionais interconectados com o mundo físico ao
          seu
          redor. Envolve a integração de dispositivos físicos e elementos de controle computacional para formar uma
          entidade coesa e colaborativa. Os sistemas ciberfísicos são projetados para interagir e se comunicar tanto
          com o ambiente físico quanto com os usuários ou outros sistemas. Essa interação é geralmente realizada por
          meio de sensores e atuadores que captam informações do mundo físico e respondem a elas com ações físicas ou
          comandos de controle.
        </p>
      </div>

      <h4>Bases Numéricas</h4>
      <div class="flex-column">
        <p>
          &emsp;As bases numéricas são sistemas de representação de números que utilizam diferentes símbolos para
          representar
          quantidades. As bases mais comuns são a base 10 (decimal), a base 2 (binária), a base 8 (octal) e a base 16
          (hexadecimal). <br>Vou explicar brevemente como funcionam essas bases:
        </p>
        <div class="flex-row" style="text-align: center;">
          <p>
            Base 10 (Decimal):<br><br>
            A base decimal é a mais familiar e amplamente utilizada no dia a dia. Ela utiliza 10 símbolos numéricos: 0,
            1, 2, 3, 4, 5, 6, 7, 8 e 9.
          </p>
          <p>
            Base 2 (Binária):<br><br>
            A base binária utiliza apenas dois símbolos: 0 e 1. A base binária é amplamente usada em sistemas
            computacionais, pois os computadores são
            baseados em circuitos eletrônicos que operam em dois estados, representados por 0 e 1.
          </p>
        </div>
        <div class="flex-row" style="text-align: center;">
          <p>
            Base 8 (Octal):<br><br>
            A base octal utiliza 8 símbolos: 0, 1, 2, 3, 4, 5, 6 e 7.
            Embora a base octal seja menos utilizada atualmente, ela ainda pode ser encontrada em algumas áreas, como
            permissões de arquivos no sistema operacional Unix.
          </p>
          <p>
            Base 16 (Hexadecimal):<br><br>
            A base hexadecimal utiliza 16 símbolos: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E e F. Os símbolos de A a
            F
            são usados para representar os valores 10 a 15. O número hexadecimal representa
            valores binários de forma mais compacta. Por exemplo, o número hexadecimal FF representa 255 em decimal.
          </p>
        </div>
      </div>
      <h4>Máquina de Turing</h4>
      <div class="flex-column">
        <p>
          &emsp;A Máquina de Turing é um modelo abstrato de um dispositivo computacional proposto pelo matemático e
          cientista
          da computação Alan Turing em 1936. É considerada uma máquina universal, pois pode simular qualquer algoritmo
          computacional, desde que haja recursos suficientes. A máquina possui um conjunto finito de estados internos, e
          seu comportamento é determinado pelas instruções contidas em uma tabela de transição. A tabela especifica a
          ação a ser tomada com base no estado atual da máquina e no símbolo lido pela cabeça de leitura/escrita. As
          ações podem incluir a gravação de um novo símbolo, o movimento da cabeça para a esquerda ou para a direita e a
          alteração do estado da máquina.<br><br>
          &emsp;A Máquina de Turing é importante porque ajudou a estabelecer as bases teóricas da ciência da computação.
          Ela
          mostrou que qualquer algoritmo computacional pode ser expresso em termos de uma Máquina de Turing, provando
          assim a noção de "computabilidade". Esse modelo teórico é usado como referência para estudar a complexidade
          computacional, a teoria da computabilidade e a lógica da programação, fornecendo uma base sólida para o
          desenvolvimento de sistemas computacionais modernos.
        </p>
      </div>
      <h4>Arquitetura de Von Neumann</h4>
      <div class="flex-column">
        <p style="display: block;">
          &emsp;Von Neumann desempenhou um papel crucial no desenvolvimento da arquitetura de computadores de programa
          armazenado. Essa arquitetura consiste em uma unidade central de processamento (CPU)
          que executa instruções armazenadas na memória. A ideia revolucionária de Von Neumann foi unir a memória do
          computador e a unidade de processamento em um único sistema, permitindo que os programas fossem armazenados e
          executados diretamente na memória. <br><br>

          &emsp; <b>Teoria dos Jogos:</b> Von Neumann fez contribuições importantes para a teoria dos jogos, uma área de
          estudo que
          analisa a tomada de decisões estratégicas. Ele desenvolveu conceitos fundamentais e modelos matemáticos que
          são amplamente utilizados na economia, ciência política e outras disciplinas. <br><br>

          &emsp; <b>Método de Monte Carlo:</b> Von Neumann contribuiu para o desenvolvimento do método de Monte Carlo,
          uma técnica
          estatística para resolver problemas complexos usando amostragem aleatória. Esse método é amplamente aplicado
          em áreas como simulações computacionais, física, engenharia e finanças.<br><br>

          &emsp; <b>Bomba de hidrogênio:</b> Durante a década de 1950, von Neumann trabalhou no desenvolvimento da bomba
          de
          hidrogênio, uma arma nuclear ainda mais poderosa do que a bomba atômica. Sua contribuição foi fundamental para
          a compreensão teórica e o projeto dessa arma.<br><br>

          &emsp; Von Neumann deixou um legado duradouro na ciência e na tecnologia, sendo reconhecido como um dos
          pioneiros da
          ciência da computação moderna e um dos maiores matemáticos do século XX.<br><br>
        </p>
      </div>


    </section>

    <section id="filo">
      <h3>Filosofia</h3>
      <div>
        <p>
          &emsp;A palavra "filosofia" tem origem grega e significa "amor à sabedoria". Os filósofos buscam analisar e
          questionar criticamente os princípios e pressupostos básicos que fundamentam a nossa compreensão do mundo.
          Eles exploram conceitos abstratos, raciocínio lógico e argumentação para examinar diferentes aspectos da
          experiência humana.
          <br><br>
          &emsp;A filosofia tem como objetivo principal a busca pela sabedoria e o desenvolvimento do pensamento
          crítico. Ela
          nos permite questionar nossas crenças e valores, bem como refletir sobre questões fundamentais, como a origem
          do universo, o sentido da vida, a natureza do bem e do mal, entre outros. Além disso, a filosofia nos ajuda a
          desenvolver habilidades de argumentação, análise e interpretação de textos complexos, o que é valioso em
          diversas áreas do conhecimento.
          <br><br>
          &emsp;Embora a filosofia não forneça respostas definitivas para todas as questões que aborda, ela desempenha
          um
          papel fundamental ao incentivar o pensamento crítico, estimular o diálogo e promover a reflexão sobre a
          condição humana. Ela pode ajudar a desenvolver uma compreensão mais profunda de nós mesmos, do mundo ao nosso
          redor e dos problemas que enfrentamos na sociedade.
          Embora seja difícil resumir toda a história da filosofia em apenas três períodos, podemos destacar três
          momentos fundamentais que tiveram um impacto significativo no desenvolvimento da disciplina. São eles:
          <br>
        </p>
        <h4>Filosofia Antiga</h4>
        <p>
          &emsp;A filosofia antiga engloba o período que se estende desde os primeiros filósofos pré-socráticos, como
          Tales de
          Mileto, até o declínio do Império Romano. Nesse período, surgiram grandes pensadores como Sócrates, Platão e
          Aristóteles na Grécia Antiga, bem como os estóicos e epicuristas. A filosofia antiga abordava questões
          fundamentais sobre a natureza da realidade, a existência dos deuses, a ética e a política.
        </p>
        <h4>Filosofia Medieval</h4>
        <p>
          &emsp;A filosofia medieval refere-se ao período que se estende aproximadamente do século V ao século XV.
          Durante a
          Idade Média, a filosofia foi influenciada pela tradição cristã e pela síntese entre a filosofia greco-romana e
          a teologia cristã. Filósofos como Santo Agostinho e Tomás de Aquino desempenharam um papel central nesse
          período, buscando conciliar a fé religiosa com o pensamento filosófico.
        </p>
        <h4>Filosofia Moderna</h4>
        <p>
          &emsp;A filosofia moderna abrange um período que vai do século XVII ao século XVIII. Esse período foi marcado
          por
          uma ruptura com a tradição medieval e um foco renovado na razão e no conhecimento científico. Filósofos como
          René Descartes, John Locke, David Hume e Immanuel Kant foram figuras-chave nessa época, abordando questões
          relacionadas à epistemologia, ontologia, ética e política, além de contribuírem para o desenvolvimento da
          ciência moderna.
        </p>
    </section>
    </div>

    <section id="ralg">
      <h3>Raciocínio Algorítmico</h3>
      <div class="flex-column">
        <div class="flex-row">
          <p>
            &emsp;Raciocínio algorítmico refere-se à habilidade de pensar e resolver problemas de forma algorítmica, ou
            seja,
            por meio de uma sequência lógica e ordenada de passos. Um algoritmo é um conjunto de instruções bem
            definidas e precisas que descrevem como resolver um problema ou executar uma tarefa. <br><br>
            &emsp;O raciocínio algorítmico envolve a capacidade de decompor um problema complexo em partes menores e
            mais
            gerenciáveis, identificar padrões e relações entre os dados, desenvolver uma estratégia de solução e
            expressá-la em termos de algoritmos claros e concisos. <br><br>
            &emsp;Esse tipo de raciocínio é fundamental na ciência da computação e na programação, pois os algoritmos
            são a
            base para a criação de software. Ao desenvolver algoritmos eficientes, os programadores podem resolver
            problemas complexos de maneira estruturada e automatizada.
          </p>
        </div>
        <h4>Jankenpon</h4>
        <div class="flex-row">
          <p>
            &emsp;Jankenpon é um termo utilizado no Japão para se referir ao popular jogo de "Pedra, Papel e Tesoura". É
            um jogo
            de mão em que dois jogadores simultaneamente escolhem entre os três objetos: pedra, papel ou tesoura. <br>
            &emsp;As regras básicas são: a pedra vence a tesoura, a tesoura vence o papel e o papel
            vence a pedra. É um jogo divertido e popular, frequentemente utilizado como forma de resolver
            disputas ou tomar decisões de forma aleatória.
          </p>
          <p style="display: block;">
            &emsp;Neste exercício, fizemos um código para reprensentar a lógica do jankenpon, sendo assim, criamos um
            algoritmo em que
            podemos escolher como vamos jogar, Player vs PC, PC vs PC ou Player vs Player. <br> &emsp;A lógica consiste
            em comparar os resultados
            entre as escolhas do <i>p1</i> e <i>p2</i>, sendo pedra, papel e tesoura sendo representados por números e
            comparados usando a lógica do código abaixo.
          </p>
        </div>
        <pre><code class="language-python" style="display:block;height: 500px;width:1000px;font-size:medium;" >
from random import randint  # importa o modulo randint que gera um numero INT randomicamente
from time import sleep  # importa o modulo sleep, que consegue controlar uma pausa entre um comando e outro

jokenpo = ["Stone", "Paper", "Scissors"]  # Lista usada para atrubuir os numeros de 0 a 2 como Pedra, Papel e Tesoura
gameMode = None
cntnue = 1
p1 = None   # Variavel do Player 1
p2 = None   # Variavel do Player 2
p1win = 0   # Variavel de score do Player 1
p2win = 0   # Variavel de score do Player 2

while gameMode != 0 and gameMode != 1 and gameMode != 2: # Loop de entrada incorreta, se um número que não seja 0,1,2 for inserido, vai repetir
    gameMode = int(input("\n--- PC vs PC (0)\n--- Player vs PC (1)\n--- Player vs Player (2)\n"))    # Variavel de selecao de modo

while cntnue == 1:  # Loop de continue, enquanto estiver 1 vai repetir
    if gameMode == 0:   # Entra no modo de jogo de PC vs PC
        p1 = randint(0, 2)
        p2 = randint(0, 2)
    elif gameMode == 1:  # Entra no modo de jogo de Player vs PC
        while p1 != 0 and p1 != 1 and p1 != 2:
            p1 = int(input("\nStone (0) Paper (1) Scissors (2)\n"))
        p2 = randint(0, 2)
    elif gameMode == 2:  # Entra no modo de jogo de Player vs Player
        while p1 != 0 and p1 != 1 and p1 != 2:
            p1 = int(input("\nPlayer 1: Stone (0) Paper (1) Scissors (2)\n"))
        while p2 != 0 and p2 != 1 and p2 != 2:
            p2 = int(input("\nPlayer 2: Stone (0) Paper (1) Scissors (2)\n"))

    print("\nScoreboard:", "\nPlayer 1:", p1win, "\nPlayer 2:", p2win)
    print("\nJO...")
    sleep(1)
    print("KEN...")
    sleep(1)
    print("PÔ!\n")
    print("P1 -",jokenpo[p1],"|","P2 -", jokenpo[p2])  # Mostra o resultado da jogada do Player 1 e Player 2
    sleep(1)

    if p1 == p2:    # Se o Player 1 for igual ao Player 2 resulta em empate
        print("Draw!")
    elif p1 == 0:     # Se o Player 1 for Pedra
        if p2 == 1:     # Se o Player 2 for Papel, ganha de Pedra
            print("Player 2 Wins!")
            p2win += 1      # Soma de score
        else:
            print("Player 1 Wins!")
            p1win += 1
    elif p1 == 1:
        if p2 == 2:
            print("Player 2 Wins!")
            p2win += 1
        else:
            print("Player 1 Wins!")
            p1win += 1
    elif p1 == 2:
        if p2 == 0:
            print("Player 2 Wins!")
            p2win += 1
        else:
            print("Player 1 Wins!")
            p1win += 1

    p1 = None   # Reset da variavel p1 para poder selecionar Pedra ou Papel ou Tesoura de novo
    p2 = None
    cntnue = int(input("\nContinue: \nNo (0) | Yes (1)\n"))

print("\nScoreboard:", "\nPlayer 1:", p1win, "\nPlayer 2:", p2win)
        </code></pre>
        <h4>Jogo da Forca</h4>
        <p>
          &emsp;O jogo da forca é um jogo de adivinhação de palavras, onde existe palavra secreta e os outros
          jogadores tentam adivinhar a palavra, fornecendo letras uma por vez. O jogo é representado por uma forca
          desenhada no papel ou em algum meio digital, com espaços em branco que representam as letras da palavra a ser
          adivinhada. <br>
          &emsp;Cada vez que um jogador adivinha uma letra correta, ela é revelada nas posições corretas da palavra.
          Caso a
          letra não esteja presente na palavra, uma parte do corpo do enforcado é adicionada à forca. <br>
          &emsp;O objetivo dos
          jogadores é adivinhar a palavra antes que o desenho da forca esteja completo. Se o desenho estiver completo
          antes de a palavra ser adivinhada, o jogador perde, caso contrário, quando adivinha corretamente a palavra,
          vence.
        </p>
        <p>
          &emsp;No código abaixo, fiz toda a lógica usando arrays para as palavras. Uma para o conjunto de palavras que
          serão usados
          outra para representar cada letra com um número, sendo 0 a letra não aparece, e 1 a letra está visível. <br>
          &emsp;Quando a quantidade de letras visíveis = total de letras da palavra, é a condição de vitória, e quando a
          variavél vida chega a 0, é a condição de derrota. <br>
          &emsp;Qualquer tentativa com uma letra que não existe na palavra for usada, adiciona a letra em uma array de
          letras usadas e diminui a variável vida em 1.
        </p>
        <pre><code class="language-python" style="display:block;height: 500px;width:1000px;font-size:medium;" >
from random import randint

carros = ["audi", "ferrari", "pontiac", "teste"]
palavra = list(carros[randint(0, len(carros) - 1)])
visibilidade = [1] * len(palavra) # Define a visibilidade de cada letra dentro da palavra
palavraVisivel = [] # Lista para esconder a palavra, caso a visibilidade mude, as letra aparecem
letraUsada = [] # Lista para mostrar as letras usadas
letraInput = None
qddLetraVisivel = 0 # Calcula quantas "visibilidade" estão 1
life = 5

for i in range(len(palavra)):
    palavraVisivel.append("_")
    qddLetraVisivel += 1

while qddLetraVisivel != 0 and life != 0:

    print(palavraVisivel)
    letraInput = input("Digite uma letra: ")

    if letraInput not in palavra: # Se a entrada não está presente na palavra atual...
        if letraInput not in letraUsada:
            life -= 1 # Se a entrada não existe na palavra atual, reduz a vida em 1
            letraUsada.append(letraInput) # Adiciona a entrada na lista de letras usadas
        else:
            print("Letra já usada,Digite novamente")
    elif letraInput in palavra and letraInput in letraUsada:
        print("Letra já usada,Digite novamente")

    else:   # Se a entrada ESTÁ presente na palavra atual...
        for i in range(len(palavra)): # Loop para verificar se existe uma ou mais da mesma entrada...
            if letraInput == palavra[i]:
                visibilidade[i] = 0 # Se a entrada existe, muda o estado do visibilidade para 0, mostrando a letra no palavraVisivel
                palavraVisivel[i] = palavra[i]
                if letraInput not in letraUsada: # Se a entrada não existe nas letras usadas, ela é adicionada
                    letraUsada.append(palavra[i])

    qddLetraVisivel = 0
    print(qddLetraVisivel)
    for i in range(len(palavra)):
        if visibilidade[i] > 0:
            qddLetraVisivel += 1

    print("Life:", life) # Mostra a quantidade de vida restante
    print("Letras Usadas: ",letraUsada)

if qddLetraVisivel == 0:
    print("Ganhou!")
    print(palavraVisivel)

if life == 0:
    print("Perdeu!")
        </code></pre>
        <h4>Mega-Sena</h4>
        <p>
          &emsp;O funcionamento da Mega-Sena é relativamente simples. Os jogadores devem escolher 6 números dentre 60
          números disponíveis, de 1 a 60. <br>
          &emsp;No código abaixo tive que fazer 2 arrays com 6 valores cada, um do número sorteado e outro dos números
          da tentativa de acerto. <br>
          &emsp;Enquanto preenche, o código testa os números para não permitir números repetidos, caso isso aconteça,
          ele gera outro número. <br>
          &emsp;E Com essas duas arrays preenchidas, testamos quantos dos números da array de tentativa estão na array
          do sorteio. <br>
          &emsp;No final ele mostra as duas arrays e quantos números acertou.
        </p>
        <pre><code class="language-python" style="display:block;height: 500px;width:1000px;font-size:medium;" >
import random

num = 0
qtdNums = 6
acertos =0
arrayResultado = []
arrayJogada = []

while len(arrayResultado) < qtdNums:
    num = random.randint(1,60)
    if num not in arrayResultado:
        arrayResultado.append(num)

while len(arrayJogada) < qtdNums:
    #num = int(input("Digite seu Número: ")) # input pessoal
    num = random.randint(1,60) # input automatico
    if num not in arrayJogada:
        arrayJogada.append(num)
    else:
        print(arrayJogada,"\nNúmero repetido, Tente novamente")

c = 0 #Contador, Counter
while c < qtdNums:
    c2 = 0
    while c2 < qtdNums:
        if arrayJogada[c] == arrayResultado[c2]:
            acertos += 1
            c2 += 1
        else:
            c2 += 1
    c += 1

print("Resultado:",arrayResultado)
print("Jogada:",arrayJogada)
print("Voçê acertou",acertos,"números")
          </code></pre>
      </div>
    </section>

    <section id="lmatm">
      <h3>Resolução de Problemas <br>com Lógica Matemática</h3>
      <div>
        <div class="flex-column">

          <p style="display: block;">
            &emsp;A lógica matemática computacional é um campo que combina os princípios da lógica matemática com a
            ciência da computação.
            Essa área de estudo é focada na aplicação de métodos lógicos e técnicas de raciocínio formal para resolver
            problemas computacionais. <br><br>

            &emsp;O cálculo proposicional, também conhecido como lógica proposicional, é uma área da lógica que trata
            das
            proposições e suas relações. No cálculo proposicional, as proposições são representadas por símbolos que
            podem ser combinados de acordo com regras específicas. <br><br>

            Aqui estão algumas informações básicas sobre o cálculo proposicional: <br><br>

            &emsp;<b>Proposições:</b> Uma proposição é uma afirmação que pode ser verdadeira ou falsa. Elas são
            representadas por
            letras maiúsculas, como P, Q, R, etc. Por exemplo, a proposição P pode representar "O sol está brilhando".
            <br><br>

            &emsp;<b>Conectivos lógicos:</b> Os conectivos lógicos são utilizados para combinar proposições e criar
            novas
            proposições. Alguns dos conectivos mais comuns são:

          </p>

          <div class="flex-row">
            <p style="display: block;">


              &emsp;&emsp;<b>Negação ():</b> Representada pelo símbolo "". A negação de uma proposição P é denotada por
              "~P" e representa a
              negação da afirmação P. Por exemplo, "~P" seria "O sol não está brilhando".<br><br>

              &emsp;&emsp;<b>Conjunção (E):</b> Representada pelo símbolo "∧" (ou "^" no teclado). A conjunção de duas
              proposições P e Q é
              denotada por "P ∧ Q" e é verdadeira apenas quando ambas as proposições são verdadeiras.<br><br>

              &emsp;&emsp;<b>Disjunção (OU):</b> Representada pelo símbolo "∨" (ou "v" no teclado). A disjunção de duas
              proposições P e Q é
              denotada por "P ∨ Q" e é verdadeira quando pelo menos uma das proposições é verdadeira.<br><br>

              &emsp;&emsp;<b>Implicação (SE...ENTÃO):</b> Representada pelo símbolo "→". A implicação de duas
              proposições
              P e Q é denotada
              por "P → Q" e é falsa apenas quando a proposição P é verdadeira e a proposição Q é falsa. Caso contrário,
              a
              implicação é verdadeira.<br><br>

              &emsp;&emsp;<b></b>Equivalência (SE E SOMENTE SE):</b> Representada pelo símbolo "↔" (ou "=" no teclado).
              A
              equivalência de duas
              proposições P e Q é denotada por "P ↔ Q" e é verdadeira apenas quando as proposições têm o mesmo valor de
              verdade (ambas verdadeiras ou ambas falsas).<br><br>
              &emsp;&emsp;<b>Tabelas-verdade:</b> As tabelas-verdade são utilizadas para determinar o valor de verdade
              de
              uma expressão no
              cálculo proposicional. Elas listam todas as combinações possíveis de valores de verdade para as
              proposições
              envolvidas e indicam o valor de verdade da expressão em cada caso.<br><br>
            </p>

            <table class="wikitable" style="text-align:center;">
              <tbody>
                <tr>
                  <th>n</th>
                  <th>Operação 1</th>
                  <th>Operação 2</th>
                  <th></th>
                  <th></th>
                  <th></th>
                  <th></th>
                  <th>nome
                  </th>
                </tr>
                <tr>
                  <td></td>
                  <td>A</td>
                  <td></td>
                  <td>V</td>
                  <td>V</td>
                  <td>F</td>
                  <td>F</td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td></td>
                  <td>B</td>
                  <td></td>
                  <td>V</td>
                  <td>F</td>
                  <td>V</td>
                  <td>F</td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>0</td>
                  <td>A∧¬A</td>
                  <td>B∧¬B</td>
                  <td>F</td>
                  <td>F</td>
                  <td>F</td>
                  <td>F</td>
                  <td>Contradição
                  </td>
                </tr>
                <tr>
                  <td>1</td>
                  <td>A↓B</td>
                  <td>¬(A∨B)</td>
                  <td>F</td>
                  <td>F</td>
                  <td>F</td>
                  <td>V</td>
                  <td>p nor q
                  </td>
                </tr>
                <tr>
                  <td>2</td>
                  <td>¬(B→A)</td>
                  <td>B∧¬A</td>
                  <td>F</td>
                  <td>F</td>
                  <td>V</td>
                  <td>F</td>
                  <td>Negação da condicional
                  </td>
                </tr>
                <tr>
                  <td>3</td>
                  <td>¬A</td>
                  <td></td>
                  <td>F</td>
                  <td>F</td>
                  <td>V</td>
                  <td>V</td>
                  <td>not A
                  </td>
                </tr>
                <tr>
                  <td>4</td>
                  <td>¬(A→B)</td>
                  <td>A∧¬B</td>
                  <td>F</td>
                  <td>V</td>
                  <td>F</td>
                  <td>F</td>
                  <td>Negação da condicional
                  </td>
                </tr>
                <tr>
                  <td>5</td>
                  <td>¬B</td>
                  <td></td>
                  <td>F</td>
                  <td>V</td>
                  <td>F</td>
                  <td>V</td>
                  <td>not B
                  </td>
                </tr>
                <tr>
                  <td>6</td>
                  <td>A<u>∨</u>B</td>
                  <td>A<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y"
                        style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"
                          alttext="{\displaystyle \oplus }">
                          <semantics>
                            <mrow class="MJX-TeXAtom-ORD">
                              <mstyle displaystyle="true" scriptlevel="0">
                                <mo>⊕<!-- ⊕ --></mo>
                              </mstyle>
                            </mrow>
                            <annotation encoding="application/x-tex">{\displaystyle \oplus }</annotation>
                          </semantics>
                        </math></span><img
                        src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8b16e2bdaefee9eed86d866e6eba3ac47c710f60"
                        class="mwe-math-fallback-image-inline" aria-hidden="true"
                        style="vertical-align: -0.505ex; width:1.808ex; height:2.176ex;" alt="\oplus "></span>B</td>
                  <td>F</td>
                  <td>V</td>
                  <td>V</td>
                  <td>F</td>
                  <td>xor
                  </td>
                </tr>
                <tr>
                  <td>7</td>
                  <td>¬(A∧B)</td>
                  <td>¬(B∧A)</td>
                  <td>F</td>
                  <td>V</td>
                  <td>V</td>
                  <td>V</td>
                  <td>nand
                  </td>
                </tr>
                <tr>
                  <td>8</td>
                  <td>A∧B</td>
                  <td>B∧A</td>
                  <td>V</td>
                  <td>F</td>
                  <td>F</td>
                  <td>F</td>
                  <td>Conjunção
                  </td>
                </tr>
                <tr>
                  <td>9</td>
                  <td>A↔B</td>
                  <td>B↔A</td>
                  <td>V</td>
                  <td>F</td>
                  <td>F</td>
                  <td>V</td>
                  <td>Bicondicional
                  </td>
                </tr>
                <tr>
                  <td>10</td>
                  <td>B</td>
                  <td></td>
                  <td>V</td>
                  <td>F</td>
                  <td>V</td>
                  <td>F</td>
                  <td>B
                  </td>
                </tr>
                <tr>
                  <td>11</td>
                  <td>A→B</td>
                  <td>¬A∨B</td>
                  <td>V</td>
                  <td>F</td>
                  <td>V</td>
                  <td>V</td>
                  <td>Condicional
                  </td>
                </tr>
                <tr>
                  <td>12</td>
                  <td>A</td>
                  <td></td>
                  <td>V</td>
                  <td>V</td>
                  <td>F</td>
                  <td>F</td>
                  <td>A
                  </td>
                </tr>
                <tr>
                  <td>13</td>
                  <td>B→A</td>
                  <td>A∨¬B</td>
                  <td>V</td>
                  <td>V</td>
                  <td>F</td>
                  <td>V</td>
                  <td>Condicional
                  </td>
                </tr>
                <tr>
                  <td>14</td>
                  <td>A∨B</td>
                  <td>B∨A</td>
                  <td>V</td>
                  <td>V</td>
                  <td>V</td>
                  <td>F</td>
                  <td>Disjunção
                  </td>
                </tr>
                <tr>
                  <td>15</td>
                  <td>A∨¬A</td>
                  <td>B∨¬B</td>
                  <td>V</td>
                  <td>V</td>
                  <td>V</td>
                  <td>V</td>
                  <td>Tautologia
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      </div>

    </section>

    <section style="max-width: 100%; margin: 0px auto; padding: 0;">
      <footer>
        <div>
          <h1 style="font-size: 40pt;">Sobre Este TDE</h1>
          <p style="background: none; font-size: 11pt;">
            Todo o conteúdo do index.html (excluindo arquivos importados) e style.css foram feitos por mim, e todos os
            projetos incluidos aqui também foram
            feitos por mim ou tiveram minha participação. <br>
            Todas as imagens disponibilizadas foram feitas e editadas por mim, com base nos projetos individuais ou em
            grupo. <br>
            Os códigos disponibilizados foram feitos por mim em projetos individuais. <br>
            O código está aberto no Github e hospedado no mesmo.
          </p>
        </div>
      </footer>
    </section>

  </main>
  <div id="sideMenu" class="sidenav">
    <a class="sideMenuButton" href="#phome" id="home">Home</a>
    <a class="sideMenuButton" href="#expcrt" id="expcreative">E. Criativa</a>
    <a class="sideMenuButton" href="#cyber" id="cybersys">S. Cyberfísicos</a>
    <a class="sideMenuButton" href="#filo" id="filosophy">Filosofia</a>
    <a class="sideMenuButton" href="#ralg" id="ralgo">R. Algoritmico</a>
    <a class="sideMenuButton" href="#lmatm" id="lmat">L. Matemática</a>
  </div>

</body>

</html>